const f = @import("externFn").externFn;
const s = @import("vulkan");

pub const createInstance = f("vkCreateInstance", fn (create_info: *const s.InstanceCreateInfo, allocator: ?*const s.AllocationCallbacks, instance: *s.Instance) callconv(.C) s.s.Result);
pub const destroyInstance = f("vkDestroyInstance", fn (instance: s.Instance, allocator: ?*const s.AllocationCallbacks) callconv(.C) void);
pub const getInstanceProcAddr = f("vkGetInstanceProcAddr", fn (instance: s.Instance, name: [*:0]const u8) callconv(.C) s.VoidFunction);
pub const enumerateInstanceExtensionProperties = f("vkEnumerateInstanceExtensionProperties", fn (layer_name: ?[*:0]const u8, ext_count: *u32, extensions: ?[*]s.ExtensionProperties) callconv(.C) s.Result);
pub const enumerateInstanceLayerProperties = f("vkEnumerateInstanceLayerProperties", fn (count: *u32, layers: ?[*]s.LayerProperties) callconv(.C) s.Result);
pub const enumeratePhysicalDevices = f("vkEnumeratePhysicalDevices", fn (instance: s.Instance, count: *u32, devices: ?[*]s.PhysicalDevice) callconv(.C) s.Result);
pub const enumerateDeviceExtensionProperties = f("vkEnumerateDeviceExtensionProperties", fn (device: s.PhysicalDevice, layer_name: ?[*:0]const u8, count: *u32, properties: ?[*]s.ExtensionProperties) callconv(.c) s.Result);
pub const getPhysicalDeviceProperties = f("vkGetPhysicalDeviceProperties", fn (device: s.PhysicalDevice, properties: *s.PhysicalDeviceProperties) callconv(.C) void);
pub const getPhysicalDeviceFeatures = f("vkGetPhysicalDeviceFeatures", fn (device: s.PhysicalDevice, properties: *s.PhysicalDeviceFeatures) callconv(.C) void);
pub const getPhysicalDeviceQueueFamilyProperties = f("vkGetPhysicalDeviceQueueFamilyProperties", fn (device: s.PhysicalDevice, count: *u32, properties: ?[*]s.QueueFamilyProperties) callconv(.C) void);
pub const createDevice = f("vkCreateDevice", fn (pdev: s.PhysicalDevice, create_info: *const s.DeviceCreateInfo, allocator: ?*const s.AllocationCallbacks, device: *s.Device) callconv(.C) s.Result);
pub const destroyDevice = f("vkDestroyDevice", fn (device: s.Device, allocator: ?*const s.AllocationCallbacks) callconv(.C) void);
pub const deviceWaitIdle = f("vkDeviceWaitIdle", fn (device: s.Device) callconv(.C) s.Result);
pub const getDeviceQueue = f("vkGetDeviceQueue", fn (device: s.Device, family_index: u32, queue_index: u32, queue: *s.Queue) callconv(.C) void);
pub const queueSubmit = f("vkQueueSubmit", fn (queue: s.Queue, submit_count: u32, submits: [*]const s.SubmitInfo, fence: s.Fence) callconv(.C) s.Result);
pub const queuePresentKHR = f("vkQueuePresentKHR", fn (queue: s.Queue, present_info: *const s.PresentInfoKHR) callconv(.C) s.Result);
pub const createXcbSurfaceKHR = f("vkCreateXcbSurfaceKHR", fn (instance: s.Instance, create_info: *const s.XcbSurfaceCreateInfoKHR, allocator: ?*const s.AllocationCallbacks, surface: *s.SurfaceKHR) callconv(.C) s.Result);
pub const createXlibSurfaceKHR = f("vkCreateXlibSurfaceKHR", fn (instance: s.Instance, create_info: *const s.XlibSurfaceCreateInfoKHR, allocator: ?*const s.AllocationCallbacks, surface: *s.SurfaceKHR) callconv(.C) s.Result);
pub const createWin32SurfaceKHR = f("vkCreateWin32SurfaceKHR", fn (instance: s.Instance, create_info: *const s.Win32SurfaceCreateInfoKHR, allocator: ?*const s.AllocationCallbacks, surface: *s.SurfaceKHR) callconv(.C) s.Result);
pub const destroySurfaceKHR = f("vkDestroySurfaceKHR", fn (instance: s.Instance, surface: s.SurfaceKHR, allocator: ?*const s.AllocationCallbacks) callconv(.C) void);
pub const getPhysicalDeviceSurfaceSupportKHR = f("vkGetPhysicalDeviceSurfaceSupportKHR", fn (device: s.PhysicalDevice, qf_index: u32, surface: s.SurfaceKHR, supported: *s.Bool32) callconv(.C) s.Result);
pub const getPhysicalDeviceSurfaceCapabilitiesKHR = f("vkGetPhysicalDeviceSurfaceCapabilitiesKHR", fn (device: s.PhysicalDevice, surface: s.SurfaceKHR, capabailities: *s.SurfaceCapabilitiesKHR) callconv(.C) s.Result);
pub const getPhysicalDeviceSurfaceFormatsKHR = f("vkGetPhysicalDeviceSurfaceFormatsKHR", fn (device: s.PhysicalDevice, surface: s.SurfaceKHR, count: *u32, formats: ?*s.SurfaceFormatKHR) callconv(.C) s.Result);
pub const getPhysicalDeviceSurfacePresentModesKHR = f("vkGetPhysicalDeviceSurfacePresentModesKHR", fn (device: s.PhysicalDevice, surface: s.SurfaceKHR, count: *u32, modes: ?*s.PresentModeKHR) callconv(.C) s.Result);
pub const createSwapchainKHR = f("vkCreateSwapchainKHR", fn (device: s.Device, create_info: *const s.SwapchainCreateInfoKHR, allocator: ?*const s.AllocationCallbacks, swapchain: *s.SwapchainKHR) callconv(.C) s.Result);
pub const destroySwapchainKHR = f("vkDestroySwapchainKHR", fn (device: s.Device, swapchain: s.SwapchainKHR, allocator: ?*const s.AllocationCallbacks) callconv(.C) void);
pub const getSwapchainImagesKHR = f("vkGetSwapchainImagesKHR", fn (device: s.Device, swapchain: s.SwapchainKHR, count: *u32, images: ?[*]s.Image) callconv(.C) s.Result);
pub const createImageView = f("vkCreateImageView", fn (device: s.Device, create_info: *const s.ImageViewCreateInfo, allocator: ?*const s.AllocationCallbacks, view: *s.ImageView) callconv(.C) s.Result);
pub const destroyImageView = f("vkDestroyImageView", fn (device: s.Device, view: s.ImageView, allocator: ?*const s.AllocationCallbacks) callconv(.C) void);
pub const createShaderModule = f("vkCreateShaderModule", fn (device: s.Device, create_info: *const s.ShaderModuleCreateInfo, allocator: ?*const s.AllocationCallbacks, shader_module: *s.ShaderModule) callconv(.C) s.Result);
pub const destroyShaderModule = f("vkDestroyShaderModule", fn (device: s.Device, shader_module: s.ShaderModule, allocator: ?*const s.AllocationCallbacks) callconv(.C) void);
pub const createPipelineLayout = f("vkCreatePipelineLayout", fn (device: s.Device, create_info: *const s.PipelineLayoutCreateInfo, allocator: ?*const s.AllocationCallbacks, pipeline_layout: *s.PipelineLayout) callconv(.C) s.Result);
pub const destroyPipelineLayout = f("vkDestroyPipelineLayout", fn (device: s.Device, pipeline_layout: s.PipelineLayout, allocator: ?*const s.AllocationCallbacks) callconv(.C) void);
pub const createRenderPass = f("vkCreateRenderPass", fn (device: s.Device, create_info: *const s.RenderPassCreateInfo, allocator: ?*const s.AllocationCallbacks, render_pass: *s.RenderPass) callconv(.C) s.Result);
pub const destroyRenderPass = f("vkDestroyRenderPass", fn (device: s.Device, render_pass: s.RenderPass, allocator: ?*const s.AllocationCallbacks) callconv(.C) void);
pub const createGraphicsPipelines = f("vkCreateGraphicsPipelines", fn (device: s.Device, cache: s.PipelineCache, create_info_count: u32, create_infos: [*]const s.GraphicsPipelineCreateInfo, allocator: ?*const s.AllocationCallbacks, pipelines: *s.Pipeline) callconv(.C) s.Result);
pub const destroyPipeline = f("vkDestroyPipeline", fn (device: s.Device, pipeline: s.Pipeline, allocator: ?*const s.AllocationCallbacks) callconv(.C) void);
pub const createFramebuffer = f("vkCreateFramebuffer", fn (device: s.Device, create_info: *const s.FramebufferCreateInfo, allocator: ?*const s.AllocationCallbacks, framebuffer: *s.Framebuffer) callconv(.C) s.Result);
pub const destroyFramebuffer = f("vkDestroyFramebuffer", fn (device: s.Device, framebuffer: s.Framebuffer, allocator: ?*const s.AllocationCallbacks) callconv(.C) void);
pub const createCommandPool = f("vkCreateCommandPool", fn (device: s.Device, create_info: *const s.CommandPoolCreateInfo, allocator: ?*const s.AllocationCallbacks, command_pool: *s.CommandPool) callconv(.c) s.Result);
pub const destroyCommandPool = f("vkDestroyCommandPool", fn (device: s.Device, command_pool: s.CommandPool, allocator: ?*const s.AllocationCallbacks) callconv(.C) void);
pub const allocateCommandBuffers = f("vkAllocateCommandBuffers", fn (device: s.Device, alloc_info: *const s.CommandBufferAllocateInfo, command_buffer: *s.CommandBuffer) callconv(.C) s.Result);
pub const beginCommandBuffer = f("vkBeginCommandBuffer", fn (command_buffer: s.CommandBuffer, begin_info: *const s.CommandBufferBeginInfo) callconv(.C) s.Result);
pub const endCommandBuffer = f("vkEndCommandBuffer", fn (command_buffer: s.CommandBuffer) callconv(.C) s.Result);
pub const resetCommandBuffer = f("vkResetCommandBuffer", fn (command_buffer: s.CommandBuffer, flags: s.CommandBufferResetFlags) callconv(.C) s.Result);
pub const cmdBeginRenderPass = f("vkCmdBeginRenderPass", fn (cmd_buf: s.CommandBuffer, begin_info: *const s.RenderPassBeginInfo, contents: s.SubpassContents) callconv(.C) void);
pub const cmdEndRenderPass = f("vkCmdEndRenderPass", fn (cmd_buf: s.CommandBuffer) callconv(.C) void);
pub const cmdBindPipeline = f("vkCmdBindPipeline", fn (cmd_buf: s.CommandBuffer, bind_point: s.PipelineBindPoint, pipeline: s.Pipeline) callconv(.C) void);
pub const cmdSetViewport = f("vkCmdSetViewport", fn (cmd_buf: s.CommandBuffer, first_viewport: u32, viewport_count: u32, viewports: *const s.Viewport) callconv(.C) void);
pub const cmdSetScissor = f("vkCmdSetScissor", fn (cmd_buf: s.CommandBuffer, first_scissor: u32, scissor_count: u32, scissors: *const s.Rect2D) callconv(.C) void);
pub const cmdDraw = f("vkCmdDraw", fn (cmd_buf: s.CommandBuffer, vertex_count: u32, instance_count: u32, first_vertex: u32, first_instance: u32) callconv(.C) void);
pub const createSemaphore = f("vkCreateSemaphore", fn (device: s.Device, create_info: *const s.SemaphoreCreateInfo, allocator: ?*const s.AllocationCallbacks, semaphore: *s.Semaphore) callconv(.C) s.Result);
pub const destroySemaphore = f("vkDestroySemaphore", fn (device: s.Device, semaphore: s.Semaphore, allocator: ?*const s.AllocationCallbacks) callconv(.C) void);
pub const createFence = f("vkCreateFence", fn (device: s.Device, create_info: *const s.FenceCreateInfo, allocator: ?*const s.AllocationCallbacks, fence: *s.s.Fence) callconv(.C) s.Result);
pub const destroyFence = f("vkDestroyFence", fn (device: s.Device, fence: s.Fence, allocator: ?*const s.AllocationCallbacks) callconv(.C) void);
pub const waitForFences = f("vkWaitForFences", fn (device: s.Device, count: u32, fences: [*]const s.Fence, wait_all: s.Bool32, timeout: u64) callconv(.C) s.Result);
pub const resetFences = f("vkResetFences", fn (device: s.Device, count: u32, fences: [*]const s.Fence) callconv(.C) s.Result);
pub const acquireNextImageKHR = f("vkAcquireNextImageKHR", fn (device: s.Device, swapchain: s.SwapchainKHR, timeout: u64, semaphore: s.Semaphore, fence: s.Fence, image_index: *u32) callconv(.C) s.Result);
